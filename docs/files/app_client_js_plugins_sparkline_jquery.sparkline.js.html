<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app\client\js\plugins\sparkline\jquery.sparkline.js - BENCHMARK DASHBOARD DOCUMENTATION</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="BENCHMARK DASHBOARD DOCUMENTATION" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: ARISTA BENCHMARK DASHBOARD</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/functionsForcronTenMinutes.js.html">functionsForcronTenMinutes.js</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/component.js.html">component.js</a></li>
                                <li><a href="../classes/makeGrahandTable.js.html">makeGrahandTable.js</a></li>
                                <li><a href="../classes/benchmarkDashboard_Process.js.html">benchmarkDashboard_Process.js</a></li>
                                <li><a href="../classes/common.js.html">common.js</a></li>
                                <li><a href="../classes/dbConfig.js.html">dbConfig.js</a></li>
                                <li><a href="../classes/dbConnect.js.html">dbConnect.js</a></li>
                                <li><a href="../classes/charts.js.html">charts.js</a></li>
                                <li><a href="../classes/functionsForcronTime12.js.html">functionsForcronTime12.js</a></li>
                                <li><a href="../classes/functionsFordbConnect.js.html">functionsFordbConnect.js</a></li>
                                <li><a href="../classes/getAllData.js.html">getAllData.js</a></li>
                                <li><a href="../classes/queries.js.html">queries.js</a></li>
                                <li><a href="../classes/server.js.html">server.js</a></li>
                                <li><a href="../classes/status.js.html">status.js</a></li>
                                <li><a href="../classes/url.js.html">url.js</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/client.html">client</a></li>
                                <li><a href="../modules/server.html">server</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app\client\js\plugins\sparkline\jquery.sparkline.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
*
* jquery.sparkline.js
*
* v2.1.2
* (c) Splunk, Inc
* Contact: Gareth Watts (gareth@splunk.com)
* http://omnipotent.net/jquery.sparkline/
*
* Generates inline sparkline charts from data supplied either to the method
* or inline in HTML
*
* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
* (Firefox 2.0+, Safari, Opera, etc)
*
* License: New BSD License
*
* Copyright (c) 2012, Splunk Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright notice,
*       this list of conditions and the following disclaimer in the documentation
*       and/or other materials provided with the distribution.
*     * Neither the name of Splunk Inc nor the names of its contributors may
*       be used to endorse or promote products derived from this software without
*       specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*
* Usage:
*  $(selector).sparkline(values, options)
*
* If values is undefined or set to &#x27;html&#x27; then the data values are read from the specified tag:
*   &lt;p&gt;Sparkline: &lt;span class=&quot;sparkline&quot;&gt;1,4,6,6,8,5,3,5&lt;/span&gt;&lt;/p&gt;
*   $(&#x27;.sparkline&#x27;).sparkline();
* There must be no spaces in the enclosed data set
*
* Otherwise values must be an array of numbers or null values
*    &lt;p&gt;Sparkline: &lt;span id=&quot;sparkline1&quot;&gt;This text replaced if the browser is compatible&lt;/span&gt;&lt;/p&gt;
*    $(&#x27;#sparkline1&#x27;).sparkline([1,4,6,6,8,5,3,5])
*    $(&#x27;#sparkline2&#x27;).sparkline([1,4,6,null,null,5,3,5])
*
* Values can also be specified in an HTML comment, or as a values attribute:
*    &lt;p&gt;Sparkline: &lt;span class=&quot;sparkline&quot;&gt;&lt;!--1,4,6,6,8,5,3,5 --&gt;&lt;/span&gt;&lt;/p&gt;
*    &lt;p&gt;Sparkline: &lt;span class=&quot;sparkline&quot; values=&quot;1,4,6,6,8,5,3,5&quot;&gt;&lt;/span&gt;&lt;/p&gt;
*    $(&#x27;.sparkline&#x27;).sparkline();
*
* For line charts, x values can also be specified:
*   &lt;p&gt;Sparkline: &lt;span class=&quot;sparkline&quot;&gt;1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5&lt;/span&gt;&lt;/p&gt;
*    $(&#x27;#sparkline1&#x27;).sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
*
* By default, options should be passed in as teh second argument to the sparkline function:
*   $(&#x27;.sparkline&#x27;).sparkline([1,2,3,4], {type: &#x27;bar&#x27;})
*
* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
* as there&#x27;s a slight performance overhead:
*   $(&#x27;.sparkline&#x27;).sparkline([1,2,3,4], {enableTagOptions: true})
*   &lt;p&gt;Sparkline: &lt;span class=&quot;sparkline&quot; sparkType=&quot;bar&quot; sparkBarColor=&quot;red&quot;&gt;loading&lt;/span&gt;&lt;/p&gt;
* Prefix all options supplied as tag attribute with &quot;spark&quot; (configurable by setting tagOptionPrefix)
*
* Supported options:
*   lineColor - Color of the line used for the chart
*   fillColor - Color used to fill in the chart - Set to &#x27;&#x27; or false for a transparent chart
*   width - Width of the chart - Defaults to 3 times the number of values in pixels
*   height - Height of the chart - Defaults to the height of the containing element
*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
*   composite - If true then don&#x27;t erase any existing chart attached to the tag, but draw
*           another chart over the top - Note that width and height are ignored if an
*           existing chart is detected.
*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to &#x27;values&#x27;
*   enableTagOptions - Whether to check tags for sparkline options
*   tagOptionPrefix - Prefix used for options supplied as tag attributes - Defaults to &#x27;spark&#x27;
*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
*           hidden dom element, avoding a browser reflow
*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
*       making the plugin perform much like it did in 1.x
*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
*       defaults to false (highlights enabled)
*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
*       callback is given arguments of (sparkline, options, fields)
*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
*       to control the format of the tooltip
*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
*   tooltipSuffix - A string to append to each field displayed in a tooltip
*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
*   tooltipValueLookups - An object or range map to map field values to tooltip strings
*       (eg. to map -1 to &quot;Lost&quot;, 0 to &quot;Draw&quot;, and 1 to &quot;Win&quot;)
*   numberFormatter - Optional callback for formatting numbers in tooltips
*   numberDigitGroupSep - Character to use for group separator in numbers &quot;1,234&quot; - Defaults to &quot;,&quot;
*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to &quot;.&quot;
*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
*
* There are 7 types of sparkline, selected by supplying a &quot;type&quot; option of &#x27;line&#x27; (default),
* &#x27;bar&#x27;, &#x27;tristate&#x27;, &#x27;bullet&#x27;, &#x27;discrete&#x27;, &#x27;pie&#x27; or &#x27;box&#x27;
*    line - Line chart.  Options:
*       spotColor - Set to &#x27;&#x27; to not end each line in a circular spot
*       minSpotColor - If set, color of spot at minimum value
*       maxSpotColor - If set, color of spot at maximum value
*       spotRadius - Radius in pixels
*       lineWidth - Width of line in pixels
*       normalRangeMin
*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the &quot;normal&quot;
*                      or expected range of values
*       normalRangeColor - Color to use for the above bar
*       drawNormalOnTop - Draw the normal range above the chart fill color if true
*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
*
*   bar - Bar chart.  Options:
*       barColor - Color of bars for postive values
*       negBarColor - Color of bars for negative values
*       zeroColor - Color of bars with zero values
*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
*       barWidth - Width of bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*       barSpacing - Gap between bars in pixels
*       zeroAxis - Centers the y-axis around zero if true
*
*   tristate - Charts values of win (&gt;0), lose (&lt;0) or draw (=0)
*       posBarColor - Color of win values
*       negBarColor - Color of lose values
*       zeroBarColor - Color of draw values
*       barWidth - Width of bars in pixels
*       barSpacing - Gap between bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*
*   discrete - Options:
*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
*       thresholdColor
*
*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
*       options:
*       targetColor - The color of the vertical target marker
*       targetWidth - The width of the target marker in pixels
*       performanceColor - The color of the performance measure horizontal bar
*       rangeColors - Colors to use for each qualitative range background color
*
*   pie - Pie chart. Options:
*       sliceColors - An array of colors to use for pie slices
*       offset - Angle in degrees to offset the first slice - Try -90 or +90
*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
*       borderColor - Color to use for the pie chart border - Defaults to #000
*
*   box - Box plot. Options:
*       raw - Set to true to supply pre-computed plot points as values
*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
*             When set to false you can supply any number of values and the box plot will
*             be computed for you.  Default is false.
*       showOutliers - Set to true (default) to display outliers as circles
*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
*       boxLineColor - Outline color of the box
*       boxFillColor - Fill color for the box
*       whiskerColor - Line color used for whiskers
*       outlierLineColor - Outline color of outlier circles
*       outlierFillColor - Fill color of the outlier circles
*       spotRadius - Radius of outlier circles
*       medianColor - Line color of the median line
*       target - Draw a target cross hair at the supplied value (default undefined)
*
*
*
*   Examples:
*   $(&#x27;#sparkline1&#x27;).sparkline(myvalues, { lineColor: &#x27;#f00&#x27;, fillColor: false });
*   $(&#x27;.barsparks&#x27;).sparkline(&#x27;html&#x27;, { type:&#x27;bar&#x27;, height:&#x27;40px&#x27;, barWidth:5 });
*   $(&#x27;#tristate&#x27;).sparkline([1,1,-1,1,0,0,-1], { type:&#x27;tristate&#x27; }):
*   $(&#x27;#discrete&#x27;).sparkline([1,3,4,5,5,3,4,5], { type:&#x27;discrete&#x27; });
*   $(&#x27;#bullet&#x27;).sparkline([10,12,12,9,7], { type:&#x27;bullet&#x27; });
*   $(&#x27;#pie&#x27;).sparkline([1,1,2], { type:&#x27;pie&#x27; });
*/

/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

(function(document, Math, undefined) { // performance/minified-size optimization
(function(factory) {
    if(typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
        define([&#x27;jquery&#x27;], factory);
    } else if (jQuery &amp;&amp; !jQuery.fn.sparkline) {
        factory(jQuery);
    }
}
(function($) {
    &#x27;use strict&#x27;;

    var UNSET_OPTION = {},
        getDefaults, createClass, SPFormat, clipval, quartile, normalizeValue, normalizeValues,
        remove, isNumber, all, sum, addCSS, ensureArray, formatNumber, RangeMap,
        MouseHandler, Tooltip, barHighlightMixin,
        line, bar, tristate, discrete, bullet, pie, box, defaultStyles, initStyles,
        VShape, VCanvas_base, VCanvas_canvas, VCanvas_vml, pending, shapeCount = 0;

    /**
     * Default configuration settings
     */
    getDefaults = function () {
        return {
            // Settings common to most/all chart types
            common: {
                type: &#x27;line&#x27;,
                lineColor: &#x27;#00f&#x27;,
                fillColor: &#x27;#cdf&#x27;,
                defaultPixelsPerValue: 3,
                width: &#x27;auto&#x27;,
                height: &#x27;auto&#x27;,
                composite: false,
                tagValuesAttribute: &#x27;values&#x27;,
                tagOptionsPrefix: &#x27;spark&#x27;,
                enableTagOptions: false,
                enableHighlight: true,
                highlightLighten: 1.4,
                tooltipSkipNull: true,
                tooltipPrefix: &#x27;&#x27;,
                tooltipSuffix: &#x27;&#x27;,
                disableHiddenCheck: false,
                numberFormatter: false,
                numberDigitGroupCount: 3,
                numberDigitGroupSep: &#x27;,&#x27;,
                numberDecimalMark: &#x27;.&#x27;,
                disableTooltips: false,
                disableInteraction: false
            },
            // Defaults for line charts
            line: {
                spotColor: &#x27;#f80&#x27;,
                highlightSpotColor: &#x27;#5f5&#x27;,
                highlightLineColor: &#x27;#f22&#x27;,
                spotRadius: 1.5,
                minSpotColor: &#x27;#f80&#x27;,
                maxSpotColor: &#x27;#f80&#x27;,
                lineWidth: 1,
                normalRangeMin: undefined,
                normalRangeMax: undefined,
                normalRangeColor: &#x27;#ccc&#x27;,
                drawNormalOnTop: false,
                chartRangeMin: undefined,
                chartRangeMax: undefined,
                chartRangeMinX: undefined,
                chartRangeMaxX: undefined,
                tooltipFormat: new SPFormat(&#x27;&lt;span style=&quot;color: {{color}}&quot;&gt;&amp;#9679;&lt;/span&gt; {{prefix}}{{y}}{{suffix}}&#x27;)
            },
            // Defaults for bar charts
            bar: {
                barColor: &#x27;#3366cc&#x27;,
                negBarColor: &#x27;#f44&#x27;,
                stackedBarColor: [&#x27;#3366cc&#x27;, &#x27;#dc3912&#x27;, &#x27;#ff9900&#x27;, &#x27;#109618&#x27;, &#x27;#66aa00&#x27;,
                    &#x27;#dd4477&#x27;, &#x27;#0099c6&#x27;, &#x27;#990099&#x27;],
                zeroColor: undefined,
                nullColor: undefined,
                zeroAxis: true,
                barWidth: 4,
                barSpacing: 1,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                colorMap: undefined,
                tooltipFormat: new SPFormat(&#x27;&lt;span style=&quot;color: {{color}}&quot;&gt;&amp;#9679;&lt;/span&gt; {{prefix}}{{value}}{{suffix}}&#x27;)
            },
            // Defaults for tristate charts
            tristate: {
                barWidth: 4,
                barSpacing: 1,
                posBarColor: &#x27;#6f6&#x27;,
                negBarColor: &#x27;#f44&#x27;,
                zeroBarColor: &#x27;#999&#x27;,
                colorMap: {},
                tooltipFormat: new SPFormat(&#x27;&lt;span style=&quot;color: {{color}}&quot;&gt;&amp;#9679;&lt;/span&gt; {{value:map}}&#x27;),
                tooltipValueLookups: { map: { &#x27;-1&#x27;: &#x27;Loss&#x27;, &#x27;0&#x27;: &#x27;Draw&#x27;, &#x27;1&#x27;: &#x27;Win&#x27; } }
            },
            // Defaults for discrete charts
            discrete: {
                lineHeight: &#x27;auto&#x27;,
                thresholdColor: undefined,
                thresholdValue: 0,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                tooltipFormat: new SPFormat(&#x27;{{prefix}}{{value}}{{suffix}}&#x27;)
            },
            // Defaults for bullet charts
            bullet: {
                targetColor: &#x27;#f33&#x27;,
                targetWidth: 3, // width of the target bar in pixels
                performanceColor: &#x27;#33f&#x27;,
                rangeColors: [&#x27;#d3dafe&#x27;, &#x27;#a8b6ff&#x27;, &#x27;#7f94ff&#x27;],
                base: undefined, // set this to a number to change the base start number
                tooltipFormat: new SPFormat(&#x27;{{fieldkey:fields}} - {{value}}&#x27;),
                tooltipValueLookups: { fields: {r: &#x27;Range&#x27;, p: &#x27;Performance&#x27;, t: &#x27;Target&#x27;} }
            },
            // Defaults for pie charts
            pie: {
                offset: 0,
                sliceColors: [&#x27;#3366cc&#x27;, &#x27;#dc3912&#x27;, &#x27;#ff9900&#x27;, &#x27;#109618&#x27;, &#x27;#66aa00&#x27;,
                    &#x27;#dd4477&#x27;, &#x27;#0099c6&#x27;, &#x27;#990099&#x27;],
                borderWidth: 0,
                borderColor: &#x27;#000&#x27;,
                tooltipFormat: new SPFormat(&#x27;&lt;span style=&quot;color: {{color}}&quot;&gt;&amp;#9679;&lt;/span&gt; {{value}} ({{percent.1}}%)&#x27;)
            },
            // Defaults for box plots
            box: {
                raw: false,
                boxLineColor: &#x27;#000&#x27;,
                boxFillColor: &#x27;#cdf&#x27;,
                whiskerColor: &#x27;#000&#x27;,
                outlierLineColor: &#x27;#333&#x27;,
                outlierFillColor: &#x27;#fff&#x27;,
                medianColor: &#x27;#f00&#x27;,
                showOutliers: true,
                outlierIQR: 1.5,
                spotRadius: 1.5,
                target: undefined,
                targetColor: &#x27;#4a2&#x27;,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                tooltipFormat: new SPFormat(&#x27;{{field:fields}}: {{value}}&#x27;),
                tooltipFormatFieldlistKey: &#x27;field&#x27;,
                tooltipValueLookups: { fields: { lq: &#x27;Lower Quartile&#x27;, med: &#x27;Median&#x27;,
                    uq: &#x27;Upper Quartile&#x27;, lo: &#x27;Left Outlier&#x27;, ro: &#x27;Right Outlier&#x27;,
                    lw: &#x27;Left Whisker&#x27;, rw: &#x27;Right Whisker&#x27;} }
            }
        };
    };

    // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
    defaultStyles = &#x27;.jqstooltip { &#x27; +
            &#x27;position: absolute;&#x27; +
            &#x27;left: 0px;&#x27; +
            &#x27;top: 0px;&#x27; +
            &#x27;visibility: hidden;&#x27; +
            &#x27;background: rgb(0, 0, 0) transparent;&#x27; +
            &#x27;background-color: rgba(0,0,0,0.6);&#x27; +
            &#x27;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);&#x27; +
            &#x27;-ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;;&#x27; +
            &#x27;color: white;&#x27; +
            &#x27;font: 10px arial, san serif;&#x27; +
            &#x27;text-align: left;&#x27; +
            &#x27;white-space: nowrap;&#x27; +
            &#x27;padding: 5px;&#x27; +
            &#x27;border: 1px solid white;&#x27; +
            &#x27;z-index: 10000;&#x27; +
            &#x27;}&#x27; +
            &#x27;.jqsfield { &#x27; +
            &#x27;color: white;&#x27; +
            &#x27;font: 10px arial, san serif;&#x27; +
            &#x27;text-align: left;&#x27; +
            &#x27;}&#x27;;

    /**
     * Utilities
     */

    createClass = function (/* [baseclass, [mixin, ...]], definition */) {
        var Class, args;
        Class = function () {
            this.init.apply(this, arguments);
        };
        if (arguments.length &gt; 1) {
            if (arguments[0]) {
                Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
                Class._super = arguments[0].prototype;
            } else {
                Class.prototype = arguments[arguments.length - 1];
            }
            if (arguments.length &gt; 2) {
                args = Array.prototype.slice.call(arguments, 1, -1);
                args.unshift(Class.prototype);
                $.extend.apply($, args);
            }
        } else {
            Class.prototype = arguments[0];
        }
        Class.prototype.cls = Class;
        return Class;
    };

    /**
     * Wraps a format string for tooltips
     * {{x}}
     * {{x.2}
     * {{x:months}}
     */
    $.SPFormatClass = SPFormat = createClass({
        fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
        precre: /(\w+)\.(\d+)/,

        init: function (format, fclass) {
            this.format = format;
            this.fclass = fclass;
        },

        render: function (fieldset, lookups, options) {
            var self = this,
                fields = fieldset,
                match, token, lookupkey, fieldvalue, prec;
            return this.format.replace(this.fre, function () {
                var lookup;
                token = arguments[1];
                lookupkey = arguments[3];
                match = self.precre.exec(token);
                if (match) {
                    prec = match[2];
                    token = match[1];
                } else {
                    prec = false;
                }
                fieldvalue = fields[token];
                if (fieldvalue === undefined) {
                    return &#x27;&#x27;;
                }
                if (lookupkey &amp;&amp; lookups &amp;&amp; lookups[lookupkey]) {
                    lookup = lookups[lookupkey];
                    if (lookup.get) { // RangeMap
                        return lookups[lookupkey].get(fieldvalue) || fieldvalue;
                    } else {
                        return lookups[lookupkey][fieldvalue] || fieldvalue;
                    }
                }
                if (isNumber(fieldvalue)) {
                    if (options.get(&#x27;numberFormatter&#x27;)) {
                        fieldvalue = options.get(&#x27;numberFormatter&#x27;)(fieldvalue);
                    } else {
                        fieldvalue = formatNumber(fieldvalue, prec,
                            options.get(&#x27;numberDigitGroupCount&#x27;),
                            options.get(&#x27;numberDigitGroupSep&#x27;),
                            options.get(&#x27;numberDecimalMark&#x27;));
                    }
                }
                return fieldvalue;
            });
        }
    });

    // convience method to avoid needing the new operator
    $.spformat = function(format, fclass) {
        return new SPFormat(format, fclass);
    };

    clipval = function (val, min, max) {
        if (val &lt; min) {
            return min;
        }
        if (val &gt; max) {
            return max;
        }
        return val;
    };

    quartile = function (values, q) {
        var vl;
        if (q === 2) {
            vl = Math.floor(values.length / 2);
            return values.length % 2 ? values[vl] : (values[vl-1] + values[vl]) / 2;
        } else {
            if (values.length % 2 ) { // odd
                vl = (values.length * q + q) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl-1];
            } else { //even
                vl = (values.length * q + 2) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 :  values[vl-1];

            }
        }
    };

    normalizeValue = function (val) {
        var nf;
        switch (val) {
            case &#x27;undefined&#x27;:
                val = undefined;
                break;
            case &#x27;null&#x27;:
                val = null;
                break;
            case &#x27;true&#x27;:
                val = true;
                break;
            case &#x27;false&#x27;:
                val = false;
                break;
            default:
                nf = parseFloat(val);
                if (val == nf) {
                    val = nf;
                }
        }
        return val;
    };

    normalizeValues = function (vals) {
        var i, result = [];
        for (i = vals.length; i--;) {
            result[i] = normalizeValue(vals[i]);
        }
        return result;
    };

    remove = function (vals, filter) {
        var i, vl, result = [];
        for (i = 0, vl = vals.length; i &lt; vl; i++) {
            if (vals[i] !== filter) {
                result.push(vals[i]);
            }
        }
        return result;
    };

    isNumber = function (num) {
        return !isNaN(parseFloat(num)) &amp;&amp; isFinite(num);
    };

    formatNumber = function (num, prec, groupsize, groupsep, decsep) {
        var p, i;
        num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split(&#x27;&#x27;);
        p = (p = $.inArray(&#x27;.&#x27;, num)) &lt; 0 ? num.length : p;
        if (p &lt; num.length) {
            num[p] = decsep;
        }
        for (i = p - groupsize; i &gt; 0; i -= groupsize) {
            num.splice(i, 0, groupsep);
        }
        return num.join(&#x27;&#x27;);
    };

    // determine if all values of an array match a value
    // returns true if the array is empty
    all = function (val, arr, ignoreNull) {
        var i;
        for (i = arr.length; i--; ) {
            if (ignoreNull &amp;&amp; arr[i] === null) continue;
            if (arr[i] !== val) {
                return false;
            }
        }
        return true;
    };

    // sums the numeric values in an array, ignoring other values
    sum = function (vals) {
        var total = 0, i;
        for (i = vals.length; i--;) {
            total += typeof vals[i] === &#x27;number&#x27; ? vals[i] : 0;
        }
        return total;
    };

    ensureArray = function (val) {
        return $.isArray(val) ? val : [val];
    };

    // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
    addCSS = function(css) {
        var tag;
        //if (&#x27;\v&#x27; == &#x27;v&#x27;) /* ie only */ {
        if (document.createStyleSheet) {
            document.createStyleSheet().cssText = css;
        } else {
            tag = document.createElement(&#x27;style&#x27;);
            tag.type = &#x27;text/css&#x27;;
            document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(tag);
            tag[(typeof document.body.style.WebkitAppearance == &#x27;string&#x27;) /* webkit only */ ? &#x27;innerText&#x27; : &#x27;innerHTML&#x27;] = css;
        }
    };

    // Provide a cross-browser interface to a few simple drawing primitives
    $.fn.simpledraw = function (width, height, useExisting, interact) {
        var target, mhandler;
        if (useExisting &amp;&amp; (target = this.data(&#x27;_jqs_vcanvas&#x27;))) {
            return target;
        }

        if ($.fn.sparkline.canvas === false) {
            // We&#x27;ve already determined that neither Canvas nor VML are available
            return false;

        } else if ($.fn.sparkline.canvas === undefined) {
            // No function defined yet -- need to see if we support Canvas or VML
            var el = document.createElement(&#x27;canvas&#x27;);
            if (!!(el.getContext &amp;&amp; el.getContext(&#x27;2d&#x27;))) {
                // Canvas is available
                $.fn.sparkline.canvas = function(width, height, target, interact) {
                    return new VCanvas_canvas(width, height, target, interact);
                };
            } else if (document.namespaces &amp;&amp; !document.namespaces.v) {
                // VML is available
                document.namespaces.add(&#x27;v&#x27;, &#x27;urn:schemas-microsoft-com:vml&#x27;, &#x27;#default#VML&#x27;);
                $.fn.sparkline.canvas = function(width, height, target, interact) {
                    return new VCanvas_vml(width, height, target);
                };
            } else {
                // Neither Canvas nor VML are available
                $.fn.sparkline.canvas = false;
                return false;
            }
        }

        if (width === undefined) {
            width = $(this).innerWidth();
        }
        if (height === undefined) {
            height = $(this).innerHeight();
        }

        target = $.fn.sparkline.canvas(width, height, this, interact);

        mhandler = $(this).data(&#x27;_jqs_mhandler&#x27;);
        if (mhandler) {
            mhandler.registerCanvas(target);
        }
        return target;
    };

    $.fn.cleardraw = function () {
        var target = this.data(&#x27;_jqs_vcanvas&#x27;);
        if (target) {
            target.reset();
        }
    };

    $.RangeMapClass = RangeMap = createClass({
        init: function (map) {
            var key, range, rangelist = [];
            for (key in map) {
                if (map.hasOwnProperty(key) &amp;&amp; typeof key === &#x27;string&#x27; &amp;&amp; key.indexOf(&#x27;:&#x27;) &gt; -1) {
                    range = key.split(&#x27;:&#x27;);
                    range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
                    range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
                    range[2] = map[key];
                    rangelist.push(range);
                }
            }
            this.map = map;
            this.rangelist = rangelist || false;
        },

        get: function (value) {
            var rangelist = this.rangelist,
                i, range, result;
            if ((result = this.map[value]) !== undefined) {
                return result;
            }
            if (rangelist) {
                for (i = rangelist.length; i--;) {
                    range = rangelist[i];
                    if (range[0] &lt;= value &amp;&amp; range[1] &gt;= value) {
                        return range[2];
                    }
                }
            }
            return undefined;
        }
    });

    // Convenience function
    $.range_map = function(map) {
        return new RangeMap(map);
    };

    MouseHandler = createClass({
        init: function (el, options) {
            var $el = $(el);
            this.$el = $el;
            this.options = options;
            this.currentPageX = 0;
            this.currentPageY = 0;
            this.el = el;
            this.splist = [];
            this.tooltip = null;
            this.over = false;
            this.displayTooltips = !options.get(&#x27;disableTooltips&#x27;);
            this.highlightEnabled = !options.get(&#x27;disableHighlight&#x27;);
        },

        registerSparkline: function (sp) {
            this.splist.push(sp);
            if (this.over) {
                this.updateDisplay();
            }
        },

        registerCanvas: function (canvas) {
            var $canvas = $(canvas.canvas);
            this.canvas = canvas;
            this.$canvas = $canvas;
            $canvas.mouseenter($.proxy(this.mouseenter, this));
            $canvas.mouseleave($.proxy(this.mouseleave, this));
            $canvas.click($.proxy(this.mouseclick, this));
        },

        reset: function (removeTooltip) {
            this.splist = [];
            if (this.tooltip &amp;&amp; removeTooltip) {
                this.tooltip.remove();
                this.tooltip = undefined;
            }
        },

        mouseclick: function (e) {
            var clickEvent = $.Event(&#x27;sparklineClick&#x27;);
            clickEvent.originalEvent = e;
            clickEvent.sparklines = this.splist;
            this.$el.trigger(clickEvent);
        },

        mouseenter: function (e) {
            $(document.body).unbind(&#x27;mousemove.jqs&#x27;);
            $(document.body).bind(&#x27;mousemove.jqs&#x27;, $.proxy(this.mousemove, this));
            this.over = true;
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (!this.tooltip &amp;&amp; this.displayTooltips) {
                this.tooltip = new Tooltip(this.options);
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        mouseleave: function () {
            $(document.body).unbind(&#x27;mousemove.jqs&#x27;);
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 sp, i;
            this.over = false;
            this.currentEl = null;

            if (this.tooltip) {
                this.tooltip.remove();
                this.tooltip = null;
            }

            for (i = 0; i &lt; spcount; i++) {
                sp = splist[i];
                if (sp.clearRegionHighlight()) {
                    needsRefresh = true;
                }
            }

            if (needsRefresh) {
                this.canvas.render();
            }
        },

        mousemove: function (e) {
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (this.tooltip) {
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        updateDisplay: function () {
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 offset = this.$canvas.offset(),
                 localX = this.currentPageX - offset.left,
                 localY = this.currentPageY - offset.top,
                 tooltiphtml, sp, i, result, changeEvent;
            if (!this.over) {
                return;
            }
            for (i = 0; i &lt; spcount; i++) {
                sp = splist[i];
                result = sp.setRegionHighlight(this.currentEl, localX, localY);
                if (result) {
                    needsRefresh = true;
                }
            }
            if (needsRefresh) {
                changeEvent = $.Event(&#x27;sparklineRegionChange&#x27;);
                changeEvent.sparklines = this.splist;
                this.$el.trigger(changeEvent);
                if (this.tooltip) {
                    tooltiphtml = &#x27;&#x27;;
                    for (i = 0; i &lt; spcount; i++) {
                        sp = splist[i];
                        tooltiphtml += sp.getCurrentRegionTooltip();
                    }
                    this.tooltip.setContent(tooltiphtml);
                }
                if (!this.disableHighlight) {
                    this.canvas.render();
                }
            }
            if (result === null) {
                this.mouseleave();
            }
        }
    });


    Tooltip = createClass({
        sizeStyle: &#x27;position: static !important;&#x27; +
            &#x27;display: block !important;&#x27; +
            &#x27;visibility: hidden !important;&#x27; +
            &#x27;float: left !important;&#x27;,

        init: function (options) {
            var tooltipClassname = options.get(&#x27;tooltipClassname&#x27;, &#x27;jqstooltip&#x27;),
                sizetipStyle = this.sizeStyle,
                offset;
            this.container = options.get(&#x27;tooltipContainer&#x27;) || document.body;
            this.tooltipOffsetX = options.get(&#x27;tooltipOffsetX&#x27;, 10);
            this.tooltipOffsetY = options.get(&#x27;tooltipOffsetY&#x27;, 12);
            // remove any previous lingering tooltip
            $(&#x27;#jqssizetip&#x27;).remove();
            $(&#x27;#jqstooltip&#x27;).remove();
            this.sizetip = $(&#x27;&lt;div/&gt;&#x27;, {
                id: &#x27;jqssizetip&#x27;,
                style: sizetipStyle,
                &#x27;class&#x27;: tooltipClassname
            });
            this.tooltip = $(&#x27;&lt;div/&gt;&#x27;, {
                id: &#x27;jqstooltip&#x27;,
                &#x27;class&#x27;: tooltipClassname
            }).appendTo(this.container);
            // account for the container&#x27;s location
            offset = this.tooltip.offset();
            this.offsetLeft = offset.left;
            this.offsetTop = offset.top;
            this.hidden = true;
            $(window).unbind(&#x27;resize.jqs scroll.jqs&#x27;);
            $(window).bind(&#x27;resize.jqs scroll.jqs&#x27;, $.proxy(this.updateWindowDims, this));
            this.updateWindowDims();
        },

        updateWindowDims: function () {
            this.scrollTop = $(window).scrollTop();
            this.scrollLeft = $(window).scrollLeft();
            this.scrollRight = this.scrollLeft + $(window).width();
            this.updatePosition();
        },

        getSize: function (content) {
            this.sizetip.html(content).appendTo(this.container);
            this.width = this.sizetip.width() + 1;
            this.height = this.sizetip.height();
            this.sizetip.remove();
        },

        setContent: function (content) {
            if (!content) {
                this.tooltip.css(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
                this.hidden = true;
                return;
            }
            this.getSize(content);
            this.tooltip.html(content)
                .css({
                    &#x27;width&#x27;: this.width,
                    &#x27;height&#x27;: this.height,
                    &#x27;visibility&#x27;: &#x27;visible&#x27;
                });
            if (this.hidden) {
                this.hidden = false;
                this.updatePosition();
            }
        },

        updatePosition: function (x, y) {
            if (x === undefined) {
                if (this.mousex === undefined) {
                    return;
                }
                x = this.mousex - this.offsetLeft;
                y = this.mousey - this.offsetTop;

            } else {
                this.mousex = x = x - this.offsetLeft;
                this.mousey = y = y - this.offsetTop;
            }
            if (!this.height || !this.width || this.hidden) {
                return;
            }

            y -= this.height + this.tooltipOffsetY;
            x += this.tooltipOffsetX;

            if (y &lt; this.scrollTop) {
                y = this.scrollTop;
            }
            if (x &lt; this.scrollLeft) {
                x = this.scrollLeft;
            } else if (x + this.width &gt; this.scrollRight) {
                x = this.scrollRight - this.width;
            }

            this.tooltip.css({
                &#x27;left&#x27;: x,
                &#x27;top&#x27;: y
            });
        },

        remove: function () {
            this.tooltip.remove();
            this.sizetip.remove();
            this.sizetip = this.tooltip = undefined;
            $(window).unbind(&#x27;resize.jqs scroll.jqs&#x27;);
        }
    });

    initStyles = function() {
        addCSS(defaultStyles);
    };

    $(initStyles);

    pending = [];
    $.fn.sparkline = function (userValues, userOptions) {
        return this.each(function () {
            var options = new $.fn.sparkline.options(this, userOptions),
                 $this = $(this),
                 render, i;
            render = function () {
                var values, width, height, tmp, mhandler, sp, vals;
                if (userValues === &#x27;html&#x27; || userValues === undefined) {
                    vals = this.getAttribute(options.get(&#x27;tagValuesAttribute&#x27;));
                    if (vals === undefined || vals === null) {
                        vals = $this.html();
                    }
                    values = vals.replace(/(^\s*&lt;!--)|(--&gt;\s*$)|\s+/g, &#x27;&#x27;).split(&#x27;,&#x27;);
                } else {
                    values = userValues;
                }

                width = options.get(&#x27;width&#x27;) === &#x27;auto&#x27; ? values.length * options.get(&#x27;defaultPixelsPerValue&#x27;) : options.get(&#x27;width&#x27;);
                if (options.get(&#x27;height&#x27;) === &#x27;auto&#x27;) {
                    if (!options.get(&#x27;composite&#x27;) || !$.data(this, &#x27;_jqs_vcanvas&#x27;)) {
                        // must be a better way to get the line height
                        tmp = document.createElement(&#x27;span&#x27;);
                        tmp.innerHTML = &#x27;a&#x27;;
                        $this.html(tmp);
                        height = $(tmp).innerHeight() || $(tmp).height();
                        $(tmp).remove();
                        tmp = null;
                    }
                } else {
                    height = options.get(&#x27;height&#x27;);
                }

                if (!options.get(&#x27;disableInteraction&#x27;)) {
                    mhandler = $.data(this, &#x27;_jqs_mhandler&#x27;);
                    if (!mhandler) {
                        mhandler = new MouseHandler(this, options);
                        $.data(this, &#x27;_jqs_mhandler&#x27;, mhandler);
                    } else if (!options.get(&#x27;composite&#x27;)) {
                        mhandler.reset();
                    }
                } else {
                    mhandler = false;
                }

                if (options.get(&#x27;composite&#x27;) &amp;&amp; !$.data(this, &#x27;_jqs_vcanvas&#x27;)) {
                    if (!$.data(this, &#x27;_jqs_errnotify&#x27;)) {
                        alert(&#x27;Attempted to attach a composite sparkline to an element with no existing sparkline&#x27;);
                        $.data(this, &#x27;_jqs_errnotify&#x27;, true);
                    }
                    return;
                }

                sp = new $.fn.sparkline[options.get(&#x27;type&#x27;)](this, values, options, width, height);

                sp.render();

                if (mhandler) {
                    mhandler.registerSparkline(sp);
                }
            };
            if (($(this).html() &amp;&amp; !options.get(&#x27;disableHiddenCheck&#x27;) &amp;&amp; $(this).is(&#x27;:hidden&#x27;)) || !$(this).parents(&#x27;body&#x27;).length) {
                if (!options.get(&#x27;composite&#x27;) &amp;&amp; $.data(this, &#x27;_jqs_pending&#x27;)) {
                    // remove any existing references to the element
                    for (i = pending.length; i; i--) {
                        if (pending[i - 1][0] == this) {
                            pending.splice(i - 1, 1);
                        }
                    }
                }
                pending.push([this, render]);
                $.data(this, &#x27;_jqs_pending&#x27;, true);
            } else {
                render.call(this);
            }
        });
    };

    $.fn.sparkline.defaults = getDefaults();


    $.sparkline_display_visible = function () {
        var el, i, pl;
        var done = [];
        for (i = 0, pl = pending.length; i &lt; pl; i++) {
            el = pending[i][0];
            if ($(el).is(&#x27;:visible&#x27;) &amp;&amp; !$(el).parents().is(&#x27;:hidden&#x27;)) {
                pending[i][1].call(el);
                $.data(pending[i][0], &#x27;_jqs_pending&#x27;, false);
                done.push(i);
            } else if (!$(el).closest(&#x27;html&#x27;).length &amp;&amp; !$.data(el, &#x27;_jqs_pending&#x27;)) {
                // element has been inserted and removed from the DOM
                // If it was not yet inserted into the dom then the .data request
                // will return true.
                // removing from the dom causes the data to be removed.
                $.data(pending[i][0], &#x27;_jqs_pending&#x27;, false);
                done.push(i);
            }
        }
        for (i = done.length; i; i--) {
            pending.splice(done[i - 1], 1);
        }
    };


    /**
     * User option handler
     */
    $.fn.sparkline.options = createClass({
        init: function (tag, userOptions) {
            var extendedOptions, defaults, base, tagOptionType;
            this.userOptions = userOptions = userOptions || {};
            this.tag = tag;
            this.tagValCache = {};
            defaults = $.fn.sparkline.defaults;
            base = defaults.common;
            this.tagOptionsPrefix = userOptions.enableTagOptions &amp;&amp; (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

            tagOptionType = this.getTagSetting(&#x27;type&#x27;);
            if (tagOptionType === UNSET_OPTION) {
                extendedOptions = defaults[userOptions.type || base.type];
            } else {
                extendedOptions = defaults[tagOptionType];
            }
            this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
        },


        getTagSetting: function (key) {
            var prefix = this.tagOptionsPrefix,
                val, i, pairs, keyval;
            if (prefix === false || prefix === undefined) {
                return UNSET_OPTION;
            }
            if (this.tagValCache.hasOwnProperty(key)) {
                val = this.tagValCache.key;
            } else {
                val = this.tag.getAttribute(prefix + key);
                if (val === undefined || val === null) {
                    val = UNSET_OPTION;
                } else if (val.substr(0, 1) === &#x27;[&#x27;) {
                    val = val.substr(1, val.length - 2).split(&#x27;,&#x27;);
                    for (i = val.length; i--;) {
                        val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, &#x27;&#x27;));
                    }
                } else if (val.substr(0, 1) === &#x27;{&#x27;) {
                    pairs = val.substr(1, val.length - 2).split(&#x27;,&#x27;);
                    val = {};
                    for (i = pairs.length; i--;) {
                        keyval = pairs[i].split(&#x27;:&#x27;, 2);
                        val[keyval[0].replace(/(^\s*)|(\s*$)/g, &#x27;&#x27;)] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, &#x27;&#x27;));
                    }
                } else {
                    val = normalizeValue(val);
                }
                this.tagValCache.key = val;
            }
            return val;
        },

        get: function (key, defaultval) {
            var tagOption = this.getTagSetting(key),
                result;
            if (tagOption !== UNSET_OPTION) {
                return tagOption;
            }
            return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
        }
    });


    $.fn.sparkline._base = createClass({
        disabled: false,

        init: function (el, values, options, width, height) {
            this.el = el;
            this.$el = $(el);
            this.values = values;
            this.options = options;
            this.width = width;
            this.height = height;
            this.currentRegion = undefined;
        },

        /**
         * Setup the canvas
         */
        initTarget: function () {
            var interactive = !this.options.get(&#x27;disableInteraction&#x27;);
            if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get(&#x27;composite&#x27;), interactive))) {
                this.disabled = true;
            } else {
                this.canvasWidth = this.target.pixelWidth;
                this.canvasHeight = this.target.pixelHeight;
            }
        },

        /**
         * Actually render the chart to the canvas
         */
        render: function () {
            if (this.disabled) {
                this.el.innerHTML = &#x27;&#x27;;
                return false;
            }
            return true;
        },

        /**
         * Return a region id for a given x/y co-ordinate
         */
        getRegion: function (x, y) {
        },

        /**
         * Highlight an item based on the moused-over x,y co-ordinate
         */
        setRegionHighlight: function (el, x, y) {
            var currentRegion = this.currentRegion,
                highlightEnabled = !this.options.get(&#x27;disableHighlight&#x27;),
                newRegion;
            if (x &gt; this.canvasWidth || y &gt; this.canvasHeight || x &lt; 0 || y &lt; 0) {
                return null;
            }
            newRegion = this.getRegion(el, x, y);
            if (currentRegion !== newRegion) {
                if (currentRegion !== undefined &amp;&amp; highlightEnabled) {
                    this.removeHighlight();
                }
                this.currentRegion = newRegion;
                if (newRegion !== undefined &amp;&amp; highlightEnabled) {
                    this.renderHighlight();
                }
                return true;
            }
            return false;
        },

        /**
         * Reset any currently highlighted item
         */
        clearRegionHighlight: function () {
            if (this.currentRegion !== undefined) {
                this.removeHighlight();
                this.currentRegion = undefined;
                return true;
            }
            return false;
        },

        renderHighlight: function () {
            this.changeHighlight(true);
        },

        removeHighlight: function () {
            this.changeHighlight(false);
        },

        changeHighlight: function (highlight)  {},

        /**
         * Fetch the HTML to display as a tooltip
         */
        getCurrentRegionTooltip: function () {
            var options = this.options,
                header = &#x27;&#x27;,
                entries = [],
                fields, formats, formatlen, fclass, text, i,
                showFields, showFieldsKey, newFields, fv,
                formatter, format, fieldlen, j;
            if (this.currentRegion === undefined) {
                return &#x27;&#x27;;
            }
            fields = this.getCurrentRegionFields();
            formatter = options.get(&#x27;tooltipFormatter&#x27;);
            if (formatter) {
                return formatter(this, options, fields);
            }
            if (options.get(&#x27;tooltipChartTitle&#x27;)) {
                header += &#x27;&lt;div class=&quot;jqs jqstitle&quot;&gt;&#x27; + options.get(&#x27;tooltipChartTitle&#x27;) + &#x27;&lt;/div&gt;\n&#x27;;
            }
            formats = this.options.get(&#x27;tooltipFormat&#x27;);
            if (!formats) {
                return &#x27;&#x27;;
            }
            if (!$.isArray(formats)) {
                formats = [formats];
            }
            if (!$.isArray(fields)) {
                fields = [fields];
            }
            showFields = this.options.get(&#x27;tooltipFormatFieldlist&#x27;);
            showFieldsKey = this.options.get(&#x27;tooltipFormatFieldlistKey&#x27;);
            if (showFields &amp;&amp; showFieldsKey) {
                // user-selected ordering of fields
                newFields = [];
                for (i = fields.length; i--;) {
                    fv = fields[i][showFieldsKey];
                    if ((j = $.inArray(fv, showFields)) != -1) {
                        newFields[j] = fields[i];
                    }
                }
                fields = newFields;
            }
            formatlen = formats.length;
            fieldlen = fields.length;
            for (i = 0; i &lt; formatlen; i++) {
                format = formats[i];
                if (typeof format === &#x27;string&#x27;) {
                    format = new SPFormat(format);
                }
                fclass = format.fclass || &#x27;jqsfield&#x27;;
                for (j = 0; j &lt; fieldlen; j++) {
                    if (!fields[j].isNull || !options.get(&#x27;tooltipSkipNull&#x27;)) {
                        $.extend(fields[j], {
                            prefix: options.get(&#x27;tooltipPrefix&#x27;),
                            suffix: options.get(&#x27;tooltipSuffix&#x27;)
                        });
                        text = format.render(fields[j], options.get(&#x27;tooltipValueLookups&#x27;), options);
                        entries.push(&#x27;&lt;div class=&quot;&#x27; + fclass + &#x27;&quot;&gt;&#x27; + text + &#x27;&lt;/div&gt;&#x27;);
                    }
                }
            }
            if (entries.length) {
                return header + entries.join(&#x27;\n&#x27;);
            }
            return &#x27;&#x27;;
        },

        getCurrentRegionFields: function () {},

        calcHighlightColor: function (color, options) {
            var highlightColor = options.get(&#x27;highlightColor&#x27;),
                lighten = options.get(&#x27;highlightLighten&#x27;),
                parse, mult, rgbnew, i;
            if (highlightColor) {
                return highlightColor;
            }
            if (lighten) {
                // extract RGB values
                parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
                if (parse) {
                    rgbnew = [];
                    mult = color.length === 4 ? 16 : 1;
                    for (i = 0; i &lt; 3; i++) {
                        rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
                    }
                    return &#x27;rgb(&#x27; + rgbnew.join(&#x27;,&#x27;) + &#x27;)&#x27;;
                }

            }
            return color;
        }

    });

    barHighlightMixin = {
        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                target = this.target,
                shapeids = this.regionShapes[currentRegion],
                newShapes;
            // will be null if the region value was null
            if (shapeids) {
                newShapes = this.renderRegion(currentRegion, highlight);
                if ($.isArray(newShapes) || $.isArray(shapeids)) {
                    target.replaceWithShapes(shapeids, newShapes);
                    this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
                        return newShape.id;
                    });
                } else {
                    target.replaceWithShape(shapeids, newShapes);
                    this.regionShapes[currentRegion] = newShapes.id;
                }
            }
        },

        render: function () {
            var values = this.values,
                target = this.target,
                regionShapes = this.regionShapes,
                shapes, ids, i, j;

            if (!this.cls._super.render.call(this)) {
                return;
            }
            for (i = values.length; i--;) {
                shapes = this.renderRegion(i);
                if (shapes) {
                    if ($.isArray(shapes)) {
                        ids = [];
                        for (j = shapes.length; j--;) {
                            shapes[j].append();
                            ids.push(shapes[j].id);
                        }
                        regionShapes[i] = ids;
                    } else {
                        shapes.append();
                        regionShapes[i] = shapes.id; // store just the shapeid
                    }
                } else {
                    // null value
                    regionShapes[i] = null;
                }
            }
            target.render();
        }
    };

    /**
     * Line charts
     */
    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
        type: &#x27;line&#x27;,

        init: function (el, values, options, width, height) {
            line._super.init.call(this, el, values, options, width, height);
            this.vertices = [];
            this.regionMap = [];
            this.xvalues = [];
            this.yvalues = [];
            this.yminmax = [];
            this.hightlightSpotId = null;
            this.lastShapeId = null;
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var i,
                regionMap = this.regionMap; // maps regions to value positions
            for (i = regionMap.length; i--;) {
                if (regionMap[i] !== null &amp;&amp; x &gt;= regionMap[i][0] &amp;&amp; x &lt;= regionMap[i][1]) {
                    return regionMap[i][2];
                }
            }
            return undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.yvalues[currentRegion] === null,
                x: this.xvalues[currentRegion],
                y: this.yvalues[currentRegion],
                color: this.options.get(&#x27;lineColor&#x27;),
                fillColor: this.options.get(&#x27;fillColor&#x27;),
                offset: currentRegion
            };
        },

        renderHighlight: function () {
            var currentRegion = this.currentRegion,
                target = this.target,
                vertex = this.vertices[currentRegion],
                options = this.options,
                spotRadius = options.get(&#x27;spotRadius&#x27;),
                highlightSpotColor = options.get(&#x27;highlightSpotColor&#x27;),
                highlightLineColor = options.get(&#x27;highlightLineColor&#x27;),
                highlightSpot, highlightLine;

            if (!vertex) {
                return;
            }
            if (spotRadius &amp;&amp; highlightSpotColor) {
                highlightSpot = target.drawCircle(vertex[0], vertex[1],
                    spotRadius, undefined, highlightSpotColor);
                this.highlightSpotId = highlightSpot.id;
                target.insertAfterShape(this.lastShapeId, highlightSpot);
            }
            if (highlightLineColor) {
                highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0],
                    this.canvasTop + this.canvasHeight, highlightLineColor);
                this.highlightLineId = highlightLine.id;
                target.insertAfterShape(this.lastShapeId, highlightLine);
            }
        },

        removeHighlight: function () {
            var target = this.target;
            if (this.highlightSpotId) {
                target.removeShapeId(this.highlightSpotId);
                this.highlightSpotId = null;
            }
            if (this.highlightLineId) {
                target.removeShapeId(this.highlightLineId);
                this.highlightLineId = null;
            }
        },

        scanValues: function () {
            var values = this.values,
                valcount = values.length,
                xvalues = this.xvalues,
                yvalues = this.yvalues,
                yminmax = this.yminmax,
                i, val, isStr, isArray, sp;
            for (i = 0; i &lt; valcount; i++) {
                val = values[i];
                isStr = typeof(values[i]) === &#x27;string&#x27;;
                isArray = typeof(values[i]) === &#x27;object&#x27; &amp;&amp; values[i] instanceof Array;
                sp = isStr &amp;&amp; values[i].split(&#x27;:&#x27;);
                if (isStr &amp;&amp; sp.length === 2) { // x:y
                    xvalues.push(Number(sp[0]));
                    yvalues.push(Number(sp[1]));
                    yminmax.push(Number(sp[1]));
                } else if (isArray) {
                    xvalues.push(val[0]);
                    yvalues.push(val[1]);
                    yminmax.push(val[1]);
                } else {
                    xvalues.push(i);
                    if (values[i] === null || values[i] === &#x27;null&#x27;) {
                        yvalues.push(null);
                    } else {
                        yvalues.push(Number(val));
                        yminmax.push(Number(val));
                    }
                }
            }
            if (this.options.get(&#x27;xvalues&#x27;)) {
                xvalues = this.options.get(&#x27;xvalues&#x27;);
            }

            this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
            this.miny = this.minyorg = Math.min.apply(Math, yminmax);

            this.maxx = Math.max.apply(Math, xvalues);
            this.minx = Math.min.apply(Math, xvalues);

            this.xvalues = xvalues;
            this.yvalues = yvalues;
            this.yminmax = yminmax;

        },

        processRangeOptions: function () {
            var options = this.options,
                normalRangeMin = options.get(&#x27;normalRangeMin&#x27;),
                normalRangeMax = options.get(&#x27;normalRangeMax&#x27;);

            if (normalRangeMin !== undefined) {
                if (normalRangeMin &lt; this.miny) {
                    this.miny = normalRangeMin;
                }
                if (normalRangeMax &gt; this.maxy) {
                    this.maxy = normalRangeMax;
                }
            }
            if (options.get(&#x27;chartRangeMin&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMin&#x27;) &lt; this.miny)) {
                this.miny = options.get(&#x27;chartRangeMin&#x27;);
            }
            if (options.get(&#x27;chartRangeMax&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMax&#x27;) &gt; this.maxy)) {
                this.maxy = options.get(&#x27;chartRangeMax&#x27;);
            }
            if (options.get(&#x27;chartRangeMinX&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClipX&#x27;) || options.get(&#x27;chartRangeMinX&#x27;) &lt; this.minx)) {
                this.minx = options.get(&#x27;chartRangeMinX&#x27;);
            }
            if (options.get(&#x27;chartRangeMaxX&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClipX&#x27;) || options.get(&#x27;chartRangeMaxX&#x27;) &gt; this.maxx)) {
                this.maxx = options.get(&#x27;chartRangeMaxX&#x27;);
            }

        },

        drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
            var normalRangeMin = this.options.get(&#x27;normalRangeMin&#x27;),
                normalRangeMax = this.options.get(&#x27;normalRangeMax&#x27;),
                ytop = canvasTop + Math.round(canvasHeight - (canvasHeight * ((normalRangeMax - this.miny) / rangey))),
                height = Math.round((canvasHeight * (normalRangeMax - normalRangeMin)) / rangey);
            this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get(&#x27;normalRangeColor&#x27;)).append();
        },

        render: function () {
            var options = this.options,
                target = this.target,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                vertices = this.vertices,
                spotRadius = options.get(&#x27;spotRadius&#x27;),
                regionMap = this.regionMap,
                rangex, rangey, yvallast,
                canvasTop, canvasLeft,
                vertex, path, paths, x, y, xnext, xpos, xposnext,
                last, next, yvalcount, lineShapes, fillShapes, plen,
                valueSpots, hlSpotsEnabled, color, xvalues, yvalues, i;

            if (!line._super.render.call(this)) {
                return;
            }

            this.scanValues();
            this.processRangeOptions();

            xvalues = this.xvalues;
            yvalues = this.yvalues;

            if (!this.yminmax.length || this.yvalues.length &lt; 2) {
                // empty or all null valuess
                return;
            }

            canvasTop = canvasLeft = 0;

            rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
            rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
            yvallast = this.yvalues.length - 1;

            if (spotRadius &amp;&amp; (canvasWidth &lt; (spotRadius * 4) || canvasHeight &lt; (spotRadius * 4))) {
                spotRadius = 0;
            }
            if (spotRadius) {
                // adjust the canvas size as required so that spots will fit
                hlSpotsEnabled = options.get(&#x27;highlightSpotColor&#x27;) &amp;&amp;  !options.get(&#x27;disableInteraction&#x27;);
                if (hlSpotsEnabled || options.get(&#x27;minSpotColor&#x27;) || (options.get(&#x27;spotColor&#x27;) &amp;&amp; yvalues[yvallast] === this.miny)) {
                    canvasHeight -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get(&#x27;maxSpotColor&#x27;) || (options.get(&#x27;spotColor&#x27;) &amp;&amp; yvalues[yvallast] === this.maxy)) {
                    canvasHeight -= Math.ceil(spotRadius);
                    canvasTop += Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled ||
                     ((options.get(&#x27;minSpotColor&#x27;) || options.get(&#x27;maxSpotColor&#x27;)) &amp;&amp; (yvalues[0] === this.miny || yvalues[0] === this.maxy))) {
                    canvasLeft += Math.ceil(spotRadius);
                    canvasWidth -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get(&#x27;spotColor&#x27;) ||
                    (options.get(&#x27;minSpotColor&#x27;) || options.get(&#x27;maxSpotColor&#x27;) &amp;&amp;
                        (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy))) {
                    canvasWidth -= Math.ceil(spotRadius);
                }
            }


            canvasHeight--;

            if (options.get(&#x27;normalRangeMin&#x27;) !== undefined &amp;&amp; !options.get(&#x27;drawNormalOnTop&#x27;)) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            path = [];
            paths = [path];
            last = next = null;
            yvalcount = yvalues.length;
            for (i = 0; i &lt; yvalcount; i++) {
                x = xvalues[i];
                xnext = xvalues[i + 1];
                y = yvalues[i];
                xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
                xposnext = i &lt; yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
                next = xpos + ((xposnext - xpos) / 2);
                regionMap[i] = [last || 0, next, i];
                last = next;
                if (y === null) {
                    if (i) {
                        if (yvalues[i - 1] !== null) {
                            path = [];
                            paths.push(path);
                        }
                        vertices.push(null);
                    }
                } else {
                    if (y &lt; this.miny) {
                        y = this.miny;
                    }
                    if (y &gt; this.maxy) {
                        y = this.maxy;
                    }
                    if (!path.length) {
                        // previous value was null
                        path.push([xpos, canvasTop + canvasHeight]);
                    }
                    vertex = [xpos, canvasTop + Math.round(canvasHeight - (canvasHeight * ((y - this.miny) / rangey)))];
                    path.push(vertex);
                    vertices.push(vertex);
                }
            }

            lineShapes = [];
            fillShapes = [];
            plen = paths.length;
            for (i = 0; i &lt; plen; i++) {
                path = paths[i];
                if (path.length) {
                    if (options.get(&#x27;fillColor&#x27;)) {
                        path.push([path[path.length - 1][0], (canvasTop + canvasHeight)]);
                        fillShapes.push(path.slice(0));
                        path.pop();
                    }
                    // if there&#x27;s only a single point in this path, then we want to display it
                    // as a vertical line which means we keep path[0]  as is
                    if (path.length &gt; 2) {
                        // else we want the first value
                        path[0] = [path[0][0], path[1][1]];
                    }
                    lineShapes.push(path);
                }
            }

            // draw the fill first, then optionally the normal range, then the line on top of that
            plen = fillShapes.length;
            for (i = 0; i &lt; plen; i++) {
                target.drawShape(fillShapes[i],
                    options.get(&#x27;fillColor&#x27;), options.get(&#x27;fillColor&#x27;)).append();
            }

            if (options.get(&#x27;normalRangeMin&#x27;) !== undefined &amp;&amp; options.get(&#x27;drawNormalOnTop&#x27;)) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            plen = lineShapes.length;
            for (i = 0; i &lt; plen; i++) {
                target.drawShape(lineShapes[i], options.get(&#x27;lineColor&#x27;), undefined,
                    options.get(&#x27;lineWidth&#x27;)).append();
            }

            if (spotRadius &amp;&amp; options.get(&#x27;valueSpots&#x27;)) {
                valueSpots = options.get(&#x27;valueSpots&#x27;);
                if (valueSpots.get === undefined) {
                    valueSpots = new RangeMap(valueSpots);
                }
                for (i = 0; i &lt; yvalcount; i++) {
                    color = valueSpots.get(yvalues[i]);
                    if (color) {
                        target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)),
                            canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[i] - this.miny) / rangey))),
                            spotRadius, undefined,
                            color).append();
                    }
                }

            }
            if (spotRadius &amp;&amp; options.get(&#x27;spotColor&#x27;) &amp;&amp; yvalues[yvallast] !== null) {
                target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)),
                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[yvallast] - this.miny) / rangey))),
                    spotRadius, undefined,
                    options.get(&#x27;spotColor&#x27;)).append();
            }
            if (this.maxy !== this.minyorg) {
                if (spotRadius &amp;&amp; options.get(&#x27;minSpotColor&#x27;)) {
                    x = xvalues[$.inArray(this.minyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.minyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get(&#x27;minSpotColor&#x27;)).append();
                }
                if (spotRadius &amp;&amp; options.get(&#x27;maxSpotColor&#x27;)) {
                    x = xvalues[$.inArray(this.maxyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.maxyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get(&#x27;maxSpotColor&#x27;)).append();
                }
            }

            this.lastShapeId = target.getLastShapeId();
            this.canvasTop = canvasTop;
            target.render();
        }
    });

    /**
     * Bar charts
     */
    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: &#x27;bar&#x27;,

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get(&#x27;barWidth&#x27;), 10),
                barSpacing = parseInt(options.get(&#x27;barSpacing&#x27;), 10),
                chartRangeMin = options.get(&#x27;chartRangeMin&#x27;),
                chartRangeMax = options.get(&#x27;chartRangeMax&#x27;),
                chartRangeClip = options.get(&#x27;chartRangeClip&#x27;),
                stackMin = Infinity,
                stackMax = -Infinity,
                isStackString, groupMin, groupMax, stackRanges,
                numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax,
                stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;
            bar._super.init.call(this, el, values, options, width, height);

            // scan values to determine whether to stack bars
            for (i = 0, vlen = values.length; i &lt; vlen; i++) {
                val = values[i];
                isStackString = typeof(val) === &#x27;string&#x27; &amp;&amp; val.indexOf(&#x27;:&#x27;) &gt; -1;
                if (isStackString || $.isArray(val)) {
                    stacked = true;
                    if (isStackString) {
                        val = values[i] = normalizeValues(val.split(&#x27;:&#x27;));
                    }
                    val = remove(val, null); // min/max will treat null as zero
                    groupMin = Math.min.apply(Math, val);
                    groupMax = Math.max.apply(Math, val);
                    if (groupMin &lt; stackMin) {
                        stackMin = groupMin;
                    }
                    if (groupMax &gt; stackMax) {
                        stackMax = groupMax;
                    }
                }
            }

            this.stacked = stacked;
            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            this.initTarget();

            if (chartRangeClip) {
                clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
                clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
            }

            numValues = [];
            stackRanges = stacked ? [] : numValues;
            var stackTotals = [];
            var stackRangesNeg = [];
            for (i = 0, vlen = values.length; i &lt; vlen; i++) {
                if (stacked) {
                    vlist = values[i];
                    values[i] = svals = [];
                    stackTotals[i] = 0;
                    stackRanges[i] = stackRangesNeg[i] = 0;
                    for (j = 0, slen = vlist.length; j &lt; slen; j++) {
                        val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
                        if (val !== null) {
                            if (val &gt; 0) {
                                stackTotals[i] += val;
                            }
                            if (stackMin &lt; 0 &amp;&amp; stackMax &gt; 0) {
                                if (val &lt; 0) {
                                    stackRangesNeg[i] += Math.abs(val);
                                } else {
                                    stackRanges[i] += val;
                                }
                            } else {
                                stackRanges[i] += Math.abs(val - (val &lt; 0 ? stackMax : stackMin));
                            }
                            numValues.push(val);
                        }
                    }
                } else {
                    val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
                    val = values[i] = normalizeValue(val);
                    if (val !== null) {
                        numValues.push(val);
                    }
                }
            }
            this.max = max = Math.max.apply(Math, numValues);
            this.min = min = Math.min.apply(Math, numValues);
            this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
            this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

            if (options.get(&#x27;chartRangeMin&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMin&#x27;) &lt; min)) {
                min = options.get(&#x27;chartRangeMin&#x27;);
            }
            if (options.get(&#x27;chartRangeMax&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMax&#x27;) &gt; max)) {
                max = options.get(&#x27;chartRangeMax&#x27;);
            }

            this.zeroAxis = zeroAxis = options.get(&#x27;zeroAxis&#x27;, true);
            if (min &lt;= 0 &amp;&amp; max &gt;= 0 &amp;&amp; zeroAxis) {
                xaxisOffset = 0;
            } else if (zeroAxis == false) {
                xaxisOffset = min;
            } else if (min &gt; 0) {
                xaxisOffset = min;
            } else {
                xaxisOffset = max;
            }
            this.xaxisOffset = xaxisOffset;

            range = stacked ? (Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg)) : max - min;

            // as we plot zero/min values a single pixel line, we add a pixel to all other
            // values - Reduce the effective canvas size to suit
            this.canvasHeightEf = (zeroAxis &amp;&amp; min &lt; 0) ? this.canvasHeight - 2 : this.canvasHeight - 1;

            if (min &lt; xaxisOffset) {
                yMaxCalc = (stacked &amp;&amp; max &gt;= 0) ? stackMax : max;
                yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
                if (yoffset !== Math.ceil(yoffset)) {
                    this.canvasHeightEf -= 2;
                    yoffset = Math.ceil(yoffset);
                }
            } else {
                yoffset = this.canvasHeight;
            }
            this.yoffset = yoffset;

            if ($.isArray(options.get(&#x27;colorMap&#x27;))) {
                this.colorMapByIndex = options.get(&#x27;colorMap&#x27;);
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get(&#x27;colorMap&#x27;);
                if (this.colorMapByValue &amp;&amp; this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }

            this.range = range;
        },

        getRegion: function (el, x, y) {
            var result = Math.floor(x / this.totalBarWidth);
            return (result &lt; 0 || result &gt;= this.values.length) ? undefined : result;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion,
                values = ensureArray(this.values[currentRegion]),
                result = [],
                value, i;
            for (i = values.length; i--;) {
                value = values[i];
                result.push({
                    isNull: value === null,
                    value: value,
                    color: this.calcColor(i, value, currentRegion),
                    offset: currentRegion
                });
            }
            return result;
        },

        calcColor: function (stacknum, value, valuenum) {
            var colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                options = this.options,
                color, newColor;
            if (this.stacked) {
                color = options.get(&#x27;stackedBarColor&#x27;);
            } else {
                color = (value &lt; 0) ? options.get(&#x27;negBarColor&#x27;) : options.get(&#x27;barColor&#x27;);
            }
            if (value === 0 &amp;&amp; options.get(&#x27;zeroColor&#x27;) !== undefined) {
                color = options.get(&#x27;zeroColor&#x27;);
            }
            if (colorMapByValue &amp;&amp; (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex &amp;&amp; colorMapByIndex.length &gt; valuenum) {
                color = colorMapByIndex[valuenum];
            }
            return $.isArray(color) ? color[stacknum % color.length] : color;
        },

        /**
         * Render bar(s) for a region
         */
        renderRegion: function (valuenum, highlight) {
            var vals = this.values[valuenum],
                options = this.options,
                xaxisOffset = this.xaxisOffset,
                result = [],
                range = this.range,
                stacked = this.stacked,
                target = this.target,
                x = valuenum * this.totalBarWidth,
                canvasHeightEf = this.canvasHeightEf,
                yoffset = this.yoffset,
                y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;

            vals = $.isArray(vals) ? vals : [vals];
            valcount = vals.length;
            val = vals[0];
            isNull = all(null, vals);
            allMin = all(xaxisOffset, vals, true);

            if (isNull) {
                if (options.get(&#x27;nullColor&#x27;)) {
                    color = highlight ? options.get(&#x27;nullColor&#x27;) : this.calcHighlightColor(options.get(&#x27;nullColor&#x27;), options);
                    y = (yoffset &gt; 0) ? yoffset - 1 : yoffset;
                    return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
                } else {
                    return undefined;
                }
            }
            yoffsetNeg = yoffset;
            for (i = 0; i &lt; valcount; i++) {
                val = vals[i];

                if (stacked &amp;&amp; val === xaxisOffset) {
                    if (!allMin || minPlotted) {
                        continue;
                    }
                    minPlotted = true;
                }

                if (range &gt; 0) {
                    height = Math.floor(canvasHeightEf * ((Math.abs(val - xaxisOffset) / range))) + 1;
                } else {
                    height = 1;
                }
                if (val &lt; xaxisOffset || (val === xaxisOffset &amp;&amp; yoffset === 0)) {
                    y = yoffsetNeg;
                    yoffsetNeg += height;
                } else {
                    y = yoffset - height;
                    yoffset -= height;
                }
                color = this.calcColor(i, val, valuenum);
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
            }
            if (result.length === 1) {
                return result[0];
            }
            return result;
        }
    });

    /**
     * Tristate charts
     */
    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: &#x27;tristate&#x27;,

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get(&#x27;barWidth&#x27;), 10),
                barSpacing = parseInt(options.get(&#x27;barSpacing&#x27;), 10);
            tristate._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.values = $.map(values, Number);
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            if ($.isArray(options.get(&#x27;colorMap&#x27;))) {
                this.colorMapByIndex = options.get(&#x27;colorMap&#x27;);
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get(&#x27;colorMap&#x27;);
                if (this.colorMapByValue &amp;&amp; this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.totalBarWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                color: this.calcColor(this.values[currentRegion], currentRegion),
                offset: currentRegion
            };
        },

        calcColor: function (value, valuenum) {
            var values = this.values,
                options = this.options,
                colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                color, newColor;

            if (colorMapByValue &amp;&amp; (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex &amp;&amp; colorMapByIndex.length &gt; valuenum) {
                color = colorMapByIndex[valuenum];
            } else if (values[valuenum] &lt; 0) {
                color = options.get(&#x27;negBarColor&#x27;);
            } else if (values[valuenum] &gt; 0) {
                color = options.get(&#x27;posBarColor&#x27;);
            } else {
                color = options.get(&#x27;zeroBarColor&#x27;);
            }
            return color;
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                target = this.target,
                canvasHeight, height, halfHeight,
                x, y, color;

            canvasHeight = target.pixelHeight;
            halfHeight = Math.round(canvasHeight / 2);

            x = valuenum * this.totalBarWidth;
            if (values[valuenum] &lt; 0) {
                y = halfHeight;
                height = halfHeight - 1;
            } else if (values[valuenum] &gt; 0) {
                y = 0;
                height = halfHeight - 1;
            } else {
                y = halfHeight - 1;
                height = 2;
            }
            color = this.calcColor(values[valuenum], valuenum);
            if (color === null) {
                return;
            }
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
        }
    });

    /**
     * Discrete charts
     */
    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: &#x27;discrete&#x27;,

        init: function (el, values, options, width, height) {
            discrete._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.values = values = $.map(values, Number);
            this.min = Math.min.apply(Math, values);
            this.max = Math.max.apply(Math, values);
            this.range = this.max - this.min;
            this.width = width = options.get(&#x27;width&#x27;) === &#x27;auto&#x27; ? values.length * 2 : this.width;
            this.interval = Math.floor(width / values.length);
            this.itemWidth = width / values.length;
            if (options.get(&#x27;chartRangeMin&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMin&#x27;) &lt; this.min)) {
                this.min = options.get(&#x27;chartRangeMin&#x27;);
            }
            if (options.get(&#x27;chartRangeMax&#x27;) !== undefined &amp;&amp; (options.get(&#x27;chartRangeClip&#x27;) || options.get(&#x27;chartRangeMax&#x27;) &gt; this.max)) {
                this.max = options.get(&#x27;chartRangeMax&#x27;);
            }
            this.initTarget();
            if (this.target) {
                this.lineHeight = options.get(&#x27;lineHeight&#x27;) === &#x27;auto&#x27; ? Math.round(this.canvasHeight * 0.3) : options.get(&#x27;lineHeight&#x27;);
            }
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.itemWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                offset: currentRegion
            };
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                min = this.min,
                max = this.max,
                range = this.range,
                interval = this.interval,
                target = this.target,
                canvasHeight = this.canvasHeight,
                lineHeight = this.lineHeight,
                pheight = canvasHeight - lineHeight,
                ytop, val, color, x;

            val = clipval(values[valuenum], min, max);
            x = valuenum * interval;
            ytop = Math.round(pheight - pheight * ((val - min) / range));
            color = (options.get(&#x27;thresholdColor&#x27;) &amp;&amp; val &lt; options.get(&#x27;thresholdValue&#x27;)) ? options.get(&#x27;thresholdColor&#x27;) : options.get(&#x27;lineColor&#x27;);
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawLine(x, ytop, x, ytop + lineHeight, color);
        }
    });

    /**
     * Bullet charts
     */
    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
        type: &#x27;bullet&#x27;,

        init: function (el, values, options, width, height) {
            var min, max, vals;
            bullet._super.init.call(this, el, values, options, width, height);

            // values: target, performance, range1, range2, range3
            this.values = values = normalizeValues(values);
            // target or performance could be null
            vals = values.slice();
            vals[0] = vals[0] === null ? vals[2] : vals[0];
            vals[1] = values[1] === null ? vals[2] : vals[1];
            min = Math.min.apply(Math, values);
            max = Math.max.apply(Math, values);
            if (options.get(&#x27;base&#x27;) === undefined) {
                min = min &lt; 0 ? min : 0;
            } else {
                min = options.get(&#x27;base&#x27;);
            }
            this.min = min;
            this.max = max;
            this.range = max - min;
            this.shapes = {};
            this.valueShapes = {};
            this.regiondata = {};
            this.width = width = options.get(&#x27;width&#x27;) === &#x27;auto&#x27; ? &#x27;4.0em&#x27; : width;
            this.target = this.$el.simpledraw(width, height, options.get(&#x27;composite&#x27;));
            if (!values.length) {
                this.disabled = true;
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined &amp;&amp; this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                fieldkey: currentRegion.substr(0, 1),
                value: this.values[currentRegion.substr(1)],
                region: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                shapeid = this.valueShapes[currentRegion],
                shape;
            delete this.shapes[shapeid];
            switch (currentRegion.substr(0, 1)) {
                case &#x27;r&#x27;:
                    shape = this.renderRange(currentRegion.substr(1), highlight);
                    break;
                case &#x27;p&#x27;:
                    shape = this.renderPerformance(highlight);
                    break;
                case &#x27;t&#x27;:
                    shape = this.renderTarget(highlight);
                    break;
            }
            this.valueShapes[currentRegion] = shape.id;
            this.shapes[shape.id] = currentRegion;
            this.target.replaceWithShape(shapeid, shape);
        },

        renderRange: function (rn, highlight) {
            var rangeval = this.values[rn],
                rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
                color = this.options.get(&#x27;rangeColors&#x27;)[rn - 2];
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
        },

        renderPerformance: function (highlight) {
            var perfval = this.values[1],
                perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
                color = this.options.get(&#x27;performanceColor&#x27;);
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1,
                Math.round(this.canvasHeight * 0.4) - 1, color, color);
        },

        renderTarget: function (highlight) {
            var targetval = this.values[0],
                x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - (this.options.get(&#x27;targetWidth&#x27;) / 2)),
                targettop = Math.round(this.canvasHeight * 0.10),
                targetheight = this.canvasHeight - (targettop * 2),
                color = this.options.get(&#x27;targetColor&#x27;);
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(x, targettop, this.options.get(&#x27;targetWidth&#x27;) - 1, targetheight - 1, color, color);
        },

        render: function () {
            var vlen = this.values.length,
                target = this.target,
                i, shape;
            if (!bullet._super.render.call(this)) {
                return;
            }
            for (i = 2; i &lt; vlen; i++) {
                shape = this.renderRange(i).append();
                this.shapes[shape.id] = &#x27;r&#x27; + i;
                this.valueShapes[&#x27;r&#x27; + i] = shape.id;
            }
            if (this.values[1] !== null) {
                shape = this.renderPerformance().append();
                this.shapes[shape.id] = &#x27;p1&#x27;;
                this.valueShapes.p1 = shape.id;
            }
            if (this.values[0] !== null) {
                shape = this.renderTarget().append();
                this.shapes[shape.id] = &#x27;t0&#x27;;
                this.valueShapes.t0 = shape.id;
            }
            target.render();
        }
    });

    /**
     * Pie charts
     */
    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
        type: &#x27;pie&#x27;,

        init: function (el, values, options, width, height) {
            var total = 0, i;

            pie._super.init.call(this, el, values, options, width, height);

            this.shapes = {}; // map shape ids to value offsets
            this.valueShapes = {}; // maps value offsets to shape ids
            this.values = values = $.map(values, Number);

            if (options.get(&#x27;width&#x27;) === &#x27;auto&#x27;) {
                this.width = this.height;
            }

            if (values.length &gt; 0) {
                for (i = values.length; i--;) {
                    total += values[i];
                }
            }
            this.total = total;
            this.initTarget();
            this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined &amp;&amp; this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                percent: this.values[currentRegion] / this.total * 100,
                color: this.options.get(&#x27;sliceColors&#x27;)[currentRegion % this.options.get(&#x27;sliceColors&#x27;).length],
                offset: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                 newslice = this.renderSlice(currentRegion, highlight),
                 shapeid = this.valueShapes[currentRegion];
            delete this.shapes[shapeid];
            this.target.replaceWithShape(shapeid, newslice);
            this.valueShapes[currentRegion] = newslice.id;
            this.shapes[newslice.id] = currentRegion;
        },

        renderSlice: function (valuenum, highlight) {
            var target = this.target,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get(&#x27;borderWidth&#x27;),
                offset = options.get(&#x27;offset&#x27;),
                circle = 2 * Math.PI,
                values = this.values,
                total = this.total,
                next = offset ? (2*Math.PI)*(offset/360) : 0,
                start, end, i, vlen, color;

            vlen = values.length;
            for (i = 0; i &lt; vlen; i++) {
                start = next;
                end = next;
                if (total &gt; 0) {  // avoid divide by zero
                    end = next + (circle * (values[i] / total));
                }
                if (valuenum === i) {
                    color = options.get(&#x27;sliceColors&#x27;)[i % options.get(&#x27;sliceColors&#x27;).length];
                    if (highlight) {
                        color = this.calcHighlightColor(color, options);
                    }

                    return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
                }
                next = end;
            }
        },

        render: function () {
            var target = this.target,
                values = this.values,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get(&#x27;borderWidth&#x27;),
                shape, i;

            if (!pie._super.render.call(this)) {
                return;
            }
            if (borderWidth) {
                target.drawCircle(radius, radius, Math.floor(radius - (borderWidth / 2)),
                    options.get(&#x27;borderColor&#x27;), undefined, borderWidth).append();
            }
            for (i = values.length; i--;) {
                if (values[i]) { // don&#x27;t render zero values
                    shape = this.renderSlice(i).append();
                    this.valueShapes[i] = shape.id; // store just the shapeid
                    this.shapes[shape.id] = i;
                }
            }
            target.render();
        }
    });

    /**
     * Box plots
     */
    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
        type: &#x27;box&#x27;,

        init: function (el, values, options, width, height) {
            box._super.init.call(this, el, values, options, width, height);
            this.values = $.map(values, Number);
            this.width = options.get(&#x27;width&#x27;) === &#x27;auto&#x27; ? &#x27;4.0em&#x27; : width;
            this.initTarget();
            if (!this.values.length) {
                this.disabled = 1;
            }
        },

        /**
         * Simulate a single region
         */
        getRegion: function () {
            return 1;
        },

        getCurrentRegionFields: function () {
            var result = [
                { field: &#x27;lq&#x27;, value: this.quartiles[0] },
                { field: &#x27;med&#x27;, value: this.quartiles[1] },
                { field: &#x27;uq&#x27;, value: this.quartiles[2] }
            ];
            if (this.loutlier !== undefined) {
                result.push({ field: &#x27;lo&#x27;, value: this.loutlier});
            }
            if (this.routlier !== undefined) {
                result.push({ field: &#x27;ro&#x27;, value: this.routlier});
            }
            if (this.lwhisker !== undefined) {
                result.push({ field: &#x27;lw&#x27;, value: this.lwhisker});
            }
            if (this.rwhisker !== undefined) {
                result.push({ field: &#x27;rw&#x27;, value: this.rwhisker});
            }
            return result;
        },

        render: function () {
            var target = this.target,
                values = this.values,
                vlen = values.length,
                options = this.options,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                minValue = options.get(&#x27;chartRangeMin&#x27;) === undefined ? Math.min.apply(Math, values) : options.get(&#x27;chartRangeMin&#x27;),
                maxValue = options.get(&#x27;chartRangeMax&#x27;) === undefined ? Math.max.apply(Math, values) : options.get(&#x27;chartRangeMax&#x27;),
                canvasLeft = 0,
                lwhisker, loutlier, iqr, q1, q2, q3, rwhisker, routlier, i,
                size, unitSize;

            if (!box._super.render.call(this)) {
                return;
            }

            if (options.get(&#x27;raw&#x27;)) {
                if (options.get(&#x27;showOutliers&#x27;) &amp;&amp; values.length &gt; 5) {
                    loutlier = values[0];
                    lwhisker = values[1];
                    q1 = values[2];
                    q2 = values[3];
                    q3 = values[4];
                    rwhisker = values[5];
                    routlier = values[6];
                } else {
                    lwhisker = values[0];
                    q1 = values[1];
                    q2 = values[2];
                    q3 = values[3];
                    rwhisker = values[4];
                }
            } else {
                values.sort(function (a, b) { return a - b; });
                q1 = quartile(values, 1);
                q2 = quartile(values, 2);
                q3 = quartile(values, 3);
                iqr = q3 - q1;
                if (options.get(&#x27;showOutliers&#x27;)) {
                    lwhisker = rwhisker = undefined;
                    for (i = 0; i &lt; vlen; i++) {
                        if (lwhisker === undefined &amp;&amp; values[i] &gt; q1 - (iqr * options.get(&#x27;outlierIQR&#x27;))) {
                            lwhisker = values[i];
                        }
                        if (values[i] &lt; q3 + (iqr * options.get(&#x27;outlierIQR&#x27;))) {
                            rwhisker = values[i];
                        }
                    }
                    loutlier = values[0];
                    routlier = values[vlen - 1];
                } else {
                    lwhisker = values[0];
                    rwhisker = values[vlen - 1];
                }
            }
            this.quartiles = [q1, q2, q3];
            this.lwhisker = lwhisker;
            this.rwhisker = rwhisker;
            this.loutlier = loutlier;
            this.routlier = routlier;

            unitSize = canvasWidth / (maxValue - minValue + 1);
            if (options.get(&#x27;showOutliers&#x27;)) {
                canvasLeft = Math.ceil(options.get(&#x27;spotRadius&#x27;));
                canvasWidth -= 2 * Math.ceil(options.get(&#x27;spotRadius&#x27;));
                unitSize = canvasWidth / (maxValue - minValue + 1);
                if (loutlier &lt; lwhisker) {
                    target.drawCircle((loutlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get(&#x27;spotRadius&#x27;),
                        options.get(&#x27;outlierLineColor&#x27;),
                        options.get(&#x27;outlierFillColor&#x27;)).append();
                }
                if (routlier &gt; rwhisker) {
                    target.drawCircle((routlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get(&#x27;spotRadius&#x27;),
                        options.get(&#x27;outlierLineColor&#x27;),
                        options.get(&#x27;outlierFillColor&#x27;)).append();
                }
            }

            // box
            target.drawRect(
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q3 - q1) * unitSize),
                Math.round(canvasHeight * 0.8),
                options.get(&#x27;boxLineColor&#x27;),
                options.get(&#x27;boxFillColor&#x27;)).append();
            // left whisker
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get(&#x27;lineColor&#x27;)).append();
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get(&#x27;whiskerColor&#x27;)).append();
            // right whisker
            target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q3 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get(&#x27;lineColor&#x27;)).append();
            target.drawLine(
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get(&#x27;whiskerColor&#x27;)).append();
            // median line
            target.drawLine(
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.9),
                options.get(&#x27;medianColor&#x27;)).append();
            if (options.get(&#x27;target&#x27;)) {
                size = Math.ceil(options.get(&#x27;spotRadius&#x27;));
                target.drawLine(
                    Math.round((options.get(&#x27;target&#x27;) - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) - size),
                    Math.round((options.get(&#x27;target&#x27;) - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) + size),
                    options.get(&#x27;targetColor&#x27;)).append();
                target.drawLine(
                    Math.round((options.get(&#x27;target&#x27;) - minValue) * unitSize + canvasLeft - size),
                    Math.round(canvasHeight / 2),
                    Math.round((options.get(&#x27;target&#x27;) - minValue) * unitSize + canvasLeft + size),
                    Math.round(canvasHeight / 2),
                    options.get(&#x27;targetColor&#x27;)).append();
            }
            target.render();
        }
    });

    // Setup a very simple &quot;virtual canvas&quot; to make drawing the few shapes we need easier
    // This is accessible as $(foo).simpledraw()

    VShape = createClass({
        init: function (target, id, type, args) {
            this.target = target;
            this.id = id;
            this.type = type;
            this.args = args;
        },
        append: function () {
            this.target.appendShape(this);
            return this;
        }
    });

    VCanvas_base = createClass({
        _pxregex: /(\d+)(px)?\s*$/i,

        init: function (width, height, target) {
            if (!width) {
                return;
            }
            this.width = width;
            this.height = height;
            this.target = target;
            this.lastShapeId = null;
            if (target[0]) {
                target = target[0];
            }
            $.data(target, &#x27;_jqs_vcanvas&#x27;, this);
        },

        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {
            return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
        },

        drawShape: function (path, lineColor, fillColor, lineWidth) {
            return this._genShape(&#x27;Shape&#x27;, [path, lineColor, fillColor, lineWidth]);
        },

        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {
            return this._genShape(&#x27;Circle&#x27;, [x, y, radius, lineColor, fillColor, lineWidth]);
        },

        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            return this._genShape(&#x27;PieSlice&#x27;, [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
        },

        drawRect: function (x, y, width, height, lineColor, fillColor) {
            return this._genShape(&#x27;Rect&#x27;, [x, y, width, height, lineColor, fillColor]);
        },

        getElement: function () {
            return this.canvas;
        },

        /**
         * Return the most recently inserted shape id
         */
        getLastShapeId: function () {
            return this.lastShapeId;
        },

        /**
         * Clear and reset the canvas
         */
        reset: function () {
            alert(&#x27;reset not implemented&#x27;);
        },

        _insert: function (el, target) {
            $(target).html(el);
        },

        /**
         * Calculate the pixel dimensions of the canvas
         */
        _calculatePixelDims: function (width, height, canvas) {
            // XXX This should probably be a configurable option
            var match;
            match = this._pxregex.exec(height);
            if (match) {
                this.pixelHeight = match[1];
            } else {
                this.pixelHeight = $(canvas).height();
            }
            match = this._pxregex.exec(width);
            if (match) {
                this.pixelWidth = match[1];
            } else {
                this.pixelWidth = $(canvas).width();
            }
        },

        /**
         * Generate a shape object and id for later rendering
         */
        _genShape: function (shapetype, shapeargs) {
            var id = shapeCount++;
            shapeargs.unshift(id);
            return new VShape(this, id, shapetype, shapeargs);
        },

        /**
         * Add a shape to the end of the render queue
         */
        appendShape: function (shape) {
            alert(&#x27;appendShape not implemented&#x27;);
        },

        /**
         * Replace one shape with another
         */
        replaceWithShape: function (shapeid, shape) {
            alert(&#x27;replaceWithShape not implemented&#x27;);
        },

        /**
         * Insert one shape after another in the render queue
         */
        insertAfterShape: function (shapeid, shape) {
            alert(&#x27;insertAfterShape not implemented&#x27;);
        },

        /**
         * Remove a shape from the queue
         */
        removeShapeId: function (shapeid) {
            alert(&#x27;removeShapeId not implemented&#x27;);
        },

        /**
         * Find a shape at the specified x/y co-ordinates
         */
        getShapeAt: function (el, x, y) {
            alert(&#x27;getShapeAt not implemented&#x27;);
        },

        /**
         * Render all queued shapes onto the canvas
         */
        render: function () {
            alert(&#x27;render not implemented&#x27;);
        }
    });

    VCanvas_canvas = createClass(VCanvas_base, {
        init: function (width, height, target, interact) {
            VCanvas_canvas._super.init.call(this, width, height, target);
            this.canvas = document.createElement(&#x27;canvas&#x27;);
            if (target[0]) {
                target = target[0];
            }
            $.data(target, &#x27;_jqs_vcanvas&#x27;, this);
            $(this.canvas).css({ display: &#x27;inline-block&#x27;, width: width, height: height, verticalAlign: &#x27;top&#x27; });
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth;
            this.canvas.height = this.pixelHeight;
            this.interact = interact;
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
            $(this.canvas).css({width: this.pixelWidth, height: this.pixelHeight});
        },

        _getContext: function (lineColor, fillColor, lineWidth) {
            var context = this.canvas.getContext(&#x27;2d&#x27;);
            if (lineColor !== undefined) {
                context.strokeStyle = lineColor;
            }
            context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
            if (fillColor !== undefined) {
                context.fillStyle = fillColor;
            }
            return context;
        },

        reset: function () {
            var context = this._getContext();
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth),
                i, plen;
            context.beginPath();
            context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
            for (i = 1, plen = path.length; i &lt; plen; i++) {
                context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
            if (this.targetX !== undefined &amp;&amp; this.targetY !== undefined &amp;&amp;
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth);
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI, false);
            if (this.targetX !== undefined &amp;&amp; this.targetY !== undefined &amp;&amp;
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var context = this._getContext(lineColor, fillColor);
            context.beginPath();
            context.moveTo(x, y);
            context.arc(x, y, radius, startAngle, endAngle, false);
            context.lineTo(x, y);
            context.closePath();
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor) {
                context.fill();
            }
            if (this.targetX !== undefined &amp;&amp; this.targetY !== undefined &amp;&amp;
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
        },

        appendShape: function (shape) {
            this.shapes[shape.id] = shape;
            this.shapeseq.push(shape.id);
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            this.shapes[shape.id] = shape;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] == shapeid) {
                    shapeseq[i] = shape.id;
                }
            }
            delete this.shapes[shapeid];
        },

        replaceWithShapes: function (shapeids, shapes) {
            var shapeseq = this.shapeseq,
                shapemap = {},
                sid, i, first;

            for (i = shapeids.length; i--;) {
                shapemap[shapeids[i]] = true;
            }
            for (i = shapeseq.length; i--;) {
                sid = shapeseq[i];
                if (shapemap[sid]) {
                    shapeseq.splice(i, 1);
                    delete this.shapes[sid];
                    first = i;
                }
            }
            for (i = shapes.length; i--;) {
                shapeseq.splice(first, 0, shapes[i].id);
                this.shapes[shapes[i].id] = shapes[i];
            }

        },

        insertAfterShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i + 1, 0, shape.id);
                    this.shapes[shape.id] = shape;
                    return;
                }
            }
        },

        removeShapeId: function (shapeid) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i, 1);
                    break;
                }
            }
            delete this.shapes[shapeid];
        },

        getShapeAt: function (el, x, y) {
            this.targetX = x;
            this.targetY = y;
            this.render();
            return this.currentTargetShapeId;
        },

        render: function () {
            var shapeseq = this.shapeseq,
                shapes = this.shapes,
                shapeCount = shapeseq.length,
                context = this._getContext(),
                shapeid, shape, i;
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            for (i = 0; i &lt; shapeCount; i++) {
                shapeid = shapeseq[i];
                shape = shapes[shapeid];
                this[&#x27;_draw&#x27; + shape.type].apply(this, shape.args);
            }
            if (!this.interact) {
                // not interactive so no need to keep the shapes array
                this.shapes = {};
                this.shapeseq = [];
            }
        }

    });

    VCanvas_vml = createClass(VCanvas_base, {
        init: function (width, height, target) {
            var groupel;
            VCanvas_vml._super.init.call(this, width, height, target);
            if (target[0]) {
                target = target[0];
            }
            $.data(target, &#x27;_jqs_vcanvas&#x27;, this);
            this.canvas = document.createElement(&#x27;span&#x27;);
            $(this.canvas).css({ display: &#x27;inline-block&#x27;, position: &#x27;relative&#x27;, overflow: &#x27;hidden&#x27;, width: width, height: height, margin: &#x27;0px&#x27;, padding: &#x27;0px&#x27;, verticalAlign: &#x27;top&#x27;});
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth;
            this.canvas.height = this.pixelHeight;
            groupel = &#x27;&lt;v:group coordorigin=&quot;0 0&quot; coordsize=&quot;&#x27; + this.pixelWidth + &#x27; &#x27; + this.pixelHeight + &#x27;&quot;&#x27; +
                    &#x27; style=&quot;position:absolute;top:0;left:0;width:&#x27; + this.pixelWidth + &#x27;px;height=&#x27; + this.pixelHeight + &#x27;px;&quot;&gt;&lt;/v:group&gt;&#x27;;
            this.canvas.insertAdjacentHTML(&#x27;beforeEnd&#x27;, groupel);
            this.group = $(this.canvas).children()[0];
            this.rendered = false;
            this.prerender = &#x27;&#x27;;
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var vpath = [],
                initial, stroke, fill, closed, vel, plen, i;
            for (i = 0, plen = path.length; i &lt; plen; i++) {
                vpath[i] = &#x27;&#x27; + (path[i][0]) + &#x27;,&#x27; + (path[i][1]);
            }
            initial = vpath.splice(0, 1);
            lineWidth = lineWidth === undefined ? 1 : lineWidth;
            stroke = lineColor === undefined ? &#x27; stroked=&quot;false&quot; &#x27; : &#x27; strokeWeight=&quot;&#x27; + lineWidth + &#x27;px&quot; strokeColor=&quot;&#x27; + lineColor + &#x27;&quot; &#x27;;
            fill = fillColor === undefined ? &#x27; filled=&quot;false&quot;&#x27; : &#x27; fillColor=&quot;&#x27; + fillColor + &#x27;&quot; filled=&quot;true&quot; &#x27;;
            closed = vpath[0] === vpath[vpath.length - 1] ? &#x27;x &#x27; : &#x27;&#x27;;
            vel = &#x27;&lt;v:shape coordorigin=&quot;0 0&quot; coordsize=&quot;&#x27; + this.pixelWidth + &#x27; &#x27; + this.pixelHeight + &#x27;&quot; &#x27; +
                 &#x27; id=&quot;jqsshape&#x27; + shapeid + &#x27;&quot; &#x27; +
                 stroke +
                 fill +
                &#x27; style=&quot;position:absolute;left:0px;top:0px;height:&#x27; + this.pixelHeight + &#x27;px;width:&#x27; + this.pixelWidth + &#x27;px;padding:0px;margin:0px;&quot; &#x27; +
                &#x27; path=&quot;m &#x27; + initial + &#x27; l &#x27; + vpath.join(&#x27;, &#x27;) + &#x27; &#x27; + closed + &#x27;e&quot;&gt;&#x27; +
                &#x27; &lt;/v:shape&gt;&#x27;;
            return vel;
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var stroke, fill, vel;
            x -= radius;
            y -= radius;
            stroke = lineColor === undefined ? &#x27; stroked=&quot;false&quot; &#x27; : &#x27; strokeWeight=&quot;&#x27; + lineWidth + &#x27;px&quot; strokeColor=&quot;&#x27; + lineColor + &#x27;&quot; &#x27;;
            fill = fillColor === undefined ? &#x27; filled=&quot;false&quot;&#x27; : &#x27; fillColor=&quot;&#x27; + fillColor + &#x27;&quot; filled=&quot;true&quot; &#x27;;
            vel = &#x27;&lt;v:oval &#x27; +
                 &#x27; id=&quot;jqsshape&#x27; + shapeid + &#x27;&quot; &#x27; +
                stroke +
                fill +
                &#x27; style=&quot;position:absolute;top:&#x27; + y + &#x27;px; left:&#x27; + x + &#x27;px; width:&#x27; + (radius * 2) + &#x27;px; height:&#x27; + (radius * 2) + &#x27;px&quot;&gt;&lt;/v:oval&gt;&#x27;;
            return vel;

        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var vpath, startx, starty, endx, endy, stroke, fill, vel;
            if (startAngle === endAngle) {
                return &#x27;&#x27;;  // VML seems to have problem when start angle equals end angle.
            }
            if ((endAngle - startAngle) === (2 * Math.PI)) {
                startAngle = 0.0;  // VML seems to have a problem when drawing a full circle that doesn&#x27;t start 0
                endAngle = (2 * Math.PI);
            }

            startx = x + Math.round(Math.cos(startAngle) * radius);
            starty = y + Math.round(Math.sin(startAngle) * radius);
            endx = x + Math.round(Math.cos(endAngle) * radius);
            endy = y + Math.round(Math.sin(endAngle) * radius);

            if (startx === endx &amp;&amp; starty === endy) {
                if ((endAngle - startAngle) &lt; Math.PI) {
                    // Prevent very small slices from being mistaken as a whole pie
                    return &#x27;&#x27;;
                }
                // essentially going to be the entire circle, so ignore startAngle
                startx = endx = x + radius;
                starty = endy = y;
            }

            if (startx === endx &amp;&amp; starty === endy &amp;&amp; (endAngle - startAngle) &lt; Math.PI) {
                return &#x27;&#x27;;
            }

            vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
            stroke = lineColor === undefined ? &#x27; stroked=&quot;false&quot; &#x27; : &#x27; strokeWeight=&quot;1px&quot; strokeColor=&quot;&#x27; + lineColor + &#x27;&quot; &#x27;;
            fill = fillColor === undefined ? &#x27; filled=&quot;false&quot;&#x27; : &#x27; fillColor=&quot;&#x27; + fillColor + &#x27;&quot; filled=&quot;true&quot; &#x27;;
            vel = &#x27;&lt;v:shape coordorigin=&quot;0 0&quot; coordsize=&quot;&#x27; + this.pixelWidth + &#x27; &#x27; + this.pixelHeight + &#x27;&quot; &#x27; +
                 &#x27; id=&quot;jqsshape&#x27; + shapeid + &#x27;&quot; &#x27; +
                 stroke +
                 fill +
                &#x27; style=&quot;position:absolute;left:0px;top:0px;height:&#x27; + this.pixelHeight + &#x27;px;width:&#x27; + this.pixelWidth + &#x27;px;padding:0px;margin:0px;&quot; &#x27; +
                &#x27; path=&quot;m &#x27; + x + &#x27;,&#x27; + y + &#x27; wa &#x27; + vpath.join(&#x27;, &#x27;) + &#x27; x e&quot;&gt;&#x27; +
                &#x27; &lt;/v:shape&gt;&#x27;;
            return vel;
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
        },

        reset: function () {
            this.group.innerHTML = &#x27;&#x27;;
        },

        appendShape: function (shape) {
            var vel = this[&#x27;_draw&#x27; + shape.type].apply(this, shape.args);
            if (this.rendered) {
                this.group.insertAdjacentHTML(&#x27;beforeEnd&#x27;, vel);
            } else {
                this.prerender += vel;
            }
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var existing = $(&#x27;#jqsshape&#x27; + shapeid),
                vel = this[&#x27;_draw&#x27; + shape.type].apply(this, shape.args);
            existing[0].outerHTML = vel;
        },

        replaceWithShapes: function (shapeids, shapes) {
            // replace the first shapeid with all the new shapes then toast the remaining old shapes
            var existing = $(&#x27;#jqsshape&#x27; + shapeids[0]),
                replace = &#x27;&#x27;,
                slen = shapes.length,
                i;
            for (i = 0; i &lt; slen; i++) {
                replace += this[&#x27;_draw&#x27; + shapes[i].type].apply(this, shapes[i].args);
            }
            existing[0].outerHTML = replace;
            for (i = 1; i &lt; shapeids.length; i++) {
                $(&#x27;#jqsshape&#x27; + shapeids[i]).remove();
            }
        },

        insertAfterShape: function (shapeid, shape) {
            var existing = $(&#x27;#jqsshape&#x27; + shapeid),
                 vel = this[&#x27;_draw&#x27; + shape.type].apply(this, shape.args);
            existing[0].insertAdjacentHTML(&#x27;afterEnd&#x27;, vel);
        },

        removeShapeId: function (shapeid) {
            var existing = $(&#x27;#jqsshape&#x27; + shapeid);
            this.group.removeChild(existing[0]);
        },

        getShapeAt: function (el, x, y) {
            var shapeid = el.id.substr(8);
            return shapeid;
        },

        render: function () {
            if (!this.rendered) {
                // batch the intial render into a single repaint
                this.group.innerHTML = this.prerender;
                this.rendered = true;
            }
        }
    });

}))}(document, Math));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
